---
title: "occupationparkingsapp"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{occupationparkingsapp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(occupationparkingsapp)
library(R6)
library(xtradata)
library(tidytable)
library(lubridate)
library(timetk)
library(ggplot2)
library(dplyr)
library(ggiraph)
```

# Classes R6

## Occupation 

On va définir une classe R6, qui va permettre d'effecteur les opérations suivantes sur les différents types de parkings (relais ou non) et secteurs d'intéret (hypercentre, centre, périphérie).

Cette classe va devoir réaliser les opérations suivantes :

- Récupération des données sur le WS d'intéret
- Nettoyage et aggregation eventuelle selon le pas de temps
- Realisation d'un graphique
- Sortie d'un tableau
- Operation de telechargement


### Création d'une nouvelle instance

```{r}
source("../R/Occupation.R")
parc_relais_hour <- Occupation$new(rangeStart = Sys.Date() - 3, rangeEnd = Sys.Date() - 1, localisation_parking = NA, parc_relais = TRUE)
centre_day <- Occupation$new(rangeStart = Sys.Date() - 3, rangeEnd = Sys.Date() - 1, localisation_parking = "centre", parc_relais = FALSE)
```

### Appel du WS de récupération des données

```{r}
parc_relais_hour$download_data(rangeStep = "hour")
centre_day$download_data(rangeStep = "day")

```
Le choix du rangeStep est des opérations qui vont en découler vont dépendre du choix de l'utilisateur.

-> données horaires
rangeStep = hour
dataviz = moyenne horaire sur la plage de temps complète

-> données journalières
rangeStep = day
dataviz = données rendues par xtradata jour par jour

-> données hebdo
rangeStep = day
dataviz = données à agreger à la semaine (moyenne)

-> données mensuelle
rangeStep = day
dataviz = données à agreger au mois (moyenne)

-> données annuelle
rangeStep = day
dataviz = données à agreger à l'année (moyenne)


```{r}
head(parc_relais_hour$data_xtradata)
# on souhaite garder dans l'output final
# ident
# time 
# libres
# total
```

### Nettoyage

```{r}
parc_relais_hour$clean_output()
head(parc_relais_hour$data_xtradata)

centre_day$clean_output()
head(centre_day$data_xtradata)

```

### Aggregation temporelle

```{r}
parc_relais_hour$mean_by_some_time_unit(time_unit = "hour")
head(parc_relais_hour$data_xtradata)

centre_day$mean_by_some_time_unit(time_unit = "day")
head(centre_day$data_xtradata)

```




```{r}
# ggplot(data = centre_day$data_xtradata, mapping = aes(x = time, y = taux_occupation, color = ident)) + 
#   geom_line()
# 
# ggplot(data = parc_relais_hour$data_xtradata, mapping = aes(x = time, y = taux_occupation, color = ident)) + 
#   geom_line()

centre_day$timeseries_plot()
parc_relais_hour$timeseries_plot()

```


# Saturation

De manière identique on va créer une classe R6 dediée.
Récupération de données, nettoyage et graphe.

En l'état on ne peut récupérer qu'une semaine via le WS. On reste là dessus.



### Création d'une nouvelle instance

```{r}
source("../R/Saturation.R")
parc_relais_hour <- Saturation$new(rangeStart = as.Date("2021-05-24"), rangeEnd = as.Date("2021-05-31"), localisation_parking = NA, parc_relais = TRUE)
```

### Appel du WS de récupération des données

```{r}
parc_relais_hour$download_data(rangeStep = "hour")
```

```{r}
parc_relais_hour$clean_output()
```

```{r}
parc_relais_hour$data_xtradata
parc_relais_hour$filter_full_capacity_parkings()
parc_relais_hour$calendar_heatmap()

n_hour_per_day_full <- parc_relais_hour$data_xtradata %>% 
  mutate.(date = as_date(time)) %>% 
  summarise.(n_hour_per_day_full = sum(taux_occupation >= .9), .by = c(ident, date)) 

n_days_per_week_full <- n_hour_per_day_full %>% 
  mutate.(week = floor_date(date, unit = "week", week_start = 1)) %>%
  summarise.(n_day_per_week_full = sum(n_hour_per_day_full >= 3), .by = c(ident, week)) 

parkings_satures <- n_days_per_week_full %>% 
  filter.(n_day_per_week_full >= 2)


# remonter à la source

data_parkings_heatmap <- parc_relais_hour$data_xtradata %>% 
  inner_join.(parkings_satures, by = "ident") %>% 
  mutate.(hours = hour(time), days = wday(time, label = TRUE), taux = taux_occupation * 100) 



# parking_test_heatmap <- parkings_satures %>% 
  # mutate.(hours = hour(time), days = wday(time, label = TRUE), taux = taux_occupation * 100) 


gg <- ggplot(data_parkings_heatmap, aes(hours, days)) +
  geom_tile(aes(fill = taux), colour = "white") +
  scale_fill_distiller(palette = "Spectral", direction = -1) +
  scale_x_continuous(breaks = 0:23) +
  facet_grid(ident ~ .) + 
  theme_minimal() + 
  theme(
    legend.position = "bottom",
    legend.key.width = unit(2, "cm"),
    panel.grid = element_blank()
  ) +
  coord_equal()

ggiraph::girafe(ggobj = gg)

# nb heures / j ooù saturation >= 90%, et nb jours >= 2 / semaine
```

